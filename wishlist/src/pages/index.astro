---
import items from "../data/items.json";
import Card from "../components/Card.astro";
import Header from "../components/Header.astro";

// Favicon (ajusta el nombre si tu archivo es "git-box.svg")
const favicon = import.meta.env.BASE_URL + "assets/gift-box.svg";
---

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>aco’s wishlist</title>
  <link rel="icon" href={favicon} type="image/svg+xml" />
</head>

<Header />

<main>
  <section class="grid" id="grid">
    {items.map((item) => <Card item={item} />)}
  </section>
</main>

<style is:global>
  /* Masonry con CSS Grid + JS: respeta el orden del DOM (para ordenar por precio) */
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
    gap: 14px;
    grid-auto-rows: 8px; /* debe coincidir con ROW en el script */
    grid-auto-flow: dense;
    padding: 18px;
  }
  .grid > .card {
    margin: 0;
  } /* el gap se encarga del espacio */

  /* (opcional) chip activo si filtras por tag desde búsqueda */
  .chip.active {
    background-color: var(--accent);
    color: #0b1220;
  }
</style>

<script is:inline>
  const ROW = 8; // Debe coincidir con grid-auto-rows
  const GAP = 14; // Debe coincidir con el gap del grid

  function relayoutMasonry(grid) {
    const cards = [...grid.children].filter(
      (el) => el.style.display !== "none"
    );
    for (const el of cards) {
      el.style.gridRowEnd = ""; // reset
      const h = el.getBoundingClientRect().height;
      const span = Math.ceil((h + GAP) / ROW);
      el.style.gridRowEnd = `span ${span}`;
    }
  }

  function imagesReady() {
    const imgs = Array.from(document.images).filter(
      (img) => !img.complete || img.naturalWidth === 0
    );
    return Promise.allSettled(
      imgs.map((img) => img.decode?.().catch(() => {}))
    );
  }

  function tokenize(q) {
    return String(q || "")
      .split(/[\s,]+/)
      .map((s) => s.trim().toLowerCase())
      .filter(Boolean);
  }

  function parsePrice(card) {
    const raw = card.getAttribute("data-price") || "";
    const num = parseFloat(raw.replace(",", "."));
    return isNaN(num) ? 0 : num;
  }

  function init() {
    const grid = document.getElementById("grid");
    const input = document.getElementById("wishlist-search");
    const select = document.getElementById("wishlist-sort");
    if (!grid) return;

    let cards = Array.from(grid.children);

    function highlightChips(terms) {
      const set = new Set(terms);
      document.querySelectorAll(".chip[data-tag]").forEach((chip) => {
        const t = (chip.dataset.tag || "").toLowerCase();
        chip.classList.toggle("active", set.has(t));
      });
    }

    function matches(card, terms) {
      if (terms.length === 0) return true;
      const haystack = (
        (card.getAttribute("data-title") || "") +
        " " +
        (card.getAttribute("data-tags") || "")
      ).toLowerCase();
      return terms.every((t) => haystack.includes(t));
    }

    function applyFilter(q) {
      const terms = tokenize(q);
      for (const card of cards) {
        card.style.display = matches(card, terms) ? "" : "none";
      }
      highlightChips(terms);
      relayoutMasonry(grid);
    }

    function applySort(order) {
      let sorted = [...cards];
      if (order === "asc") sorted.sort((a, b) => parsePrice(a) - parsePrice(b));
      else if (order === "desc")
        sorted.sort((a, b) => parsePrice(b) - parsePrice(a));
      // Reinyecta en el DOM en el nuevo orden
      for (const c of sorted) grid.appendChild(c);
      // Actualiza referencia base
      cards = sorted;
      relayoutMasonry(grid);
    }

    // Eventos
    document.addEventListener("wishlist:query", (e) => applyFilter(e.detail));
    select?.addEventListener("change", () => applySort(select.value));

    // Clic en chip: toggle el término en el input y filtra (AND con otros términos)
    document.addEventListener("click", (e) => {
      const chip = e.target.closest(".chip[data-tag]");
      if (!chip) return;
      const term = (chip.dataset.tag || "").toLowerCase();
      const terms = new Set(tokenize(input?.value || ""));
      terms.has(term) ? terms.delete(term) : terms.add(term);
      const next = Array.from(terms).join(" ");
      if (input) input.value = next;
      applyFilter(next);
    });

    // Relayout cuando las imágenes estén listas y al redimensionar
    imagesReady().finally(() => relayoutMasonry(grid));
    let rid;
    window.addEventListener("resize", () => {
      cancelAnimationFrame(rid);
      rid = requestAnimationFrame(() => relayoutMasonry(grid));
    });
  }

  if (document.readyState === "loading")
    document.addEventListener("DOMContentLoaded", init);
  else init();
</script>
